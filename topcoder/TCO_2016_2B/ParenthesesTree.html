<html><body bgcolor="#000000" text="#00ff00"><table><tr><td colspan="2"><h3>Problem Statement</h3></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td>Correct parentheses sequences can be defined recursively as follows:
<ul>
<li>The empty string "" is a correct sequence.</li>
<li>If "X" and "Y" are correct sequences, then "XY" (the concatenation of X and Y) is a correct sequence.</li>
<li>If "X" is a correct sequence, then "(X)" is a correct sequence.</li>
<li>Each correct parentheses sequence can be derived using the above rules.</li>
</ul>
Examples of correct parentheses sequences include "", "()", "()()()", "(()())", and "(((())))".<br></br>
<br></br>
We have a rooted tree with n vertices.
The vertices are labeled 0 through n-1.
For each vertex v, the parent of v has a smaller number than v.
(Hence, vertex 0 is the root: the only vertex with no parent.)
<br></br>
<br></br>
You are given the description of the tree: the vector &lt;int&gt; <b>p</b> with n-1 elements.
For each valid i, vertex <b>p</b>[i] is the parent of vertex (i+1).
<br></br>
<br></br>
You are required to place a single parenthesis onto each edge of the tree.
Once you do that, each walk on our tree will produce a sequence of parentheses.
Note that the direction of walking will matter.
For example, if the edge (x,y) has a label that reads '(' when we go from x to y, the same label reads ')' when we go from y to x.
<br></br>
<br></br>
Different labels may have different costs.
You are given these costs in the vector &lt;int&gt;s <b>L</b> and <b>R</b>.
For each valid i:
<ul>
<li>Using the label that reads '(' when we go from <b>p</b>[i] to (i+1) costs <b>L</b>[i].</li>
<li>Using the label that reads ')' when we go from <b>p</b>[i] to (i+1) costs <b>R</b>[i].</li>
</ul>
Note that you cannot leave an edge unlabeled, you must always choose one of the two available labels.
<br></br>
<br></br>
Finally, you are given a set of constraints.
These are given in the vector &lt;int&gt;s <b>a</b> and <b>b</b>.
For each valid i, consider the unique simple path from the vertex <b>a</b>[i] to the vertex <b>b</b>[i] in our tree.
The string we'll read along this path must be a valid parentheses sequence.
<br></br>
<br></br>
Compute and return the minimal cost of choosing the n-1 labels in such a way that all constraints are satisfied.
If it is impossible to satisfy all constraints, return -1 instead.</td></tr><tr><td colspan="2"><h3>Definition</h3></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td>Class:</td><td>ParenthesesTree</td></tr><tr><td>Method:</td><td>minCost</td></tr><tr><td>Parameters:</td><td>vector &lt;int&gt;, vector &lt;int&gt;, vector &lt;int&gt;, vector &lt;int&gt;, vector &lt;int&gt;</td></tr><tr><td>Returns:</td><td>int</td></tr><tr><td>Method signature:</td><td>int minCost(vector &lt;int&gt; p, vector &lt;int&gt; L, vector &lt;int&gt; R, vector &lt;int&gt; a, vector &lt;int&gt; b)</td></tr><tr><td colspan="2">(be sure your method is public)</td></tr></table></td></tr><tr><td colspan="2"><h3>Limits</h3></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td>Time limit (s):</td><td>2.000</td></tr><tr><td>Memory limit (MB):</td><td>256</td></tr></table></td></tr><tr><td colspan="2"><h3>Constraints</h3></td></tr><tr><td align="center" valign="top">-</td><td>n will be between 2 and 50, inclusive.</td></tr><tr><td align="center" valign="top">-</td><td><b>p</b>, <b>L</b> and <b>R</b> will contain exactly n-1 elements.</td></tr><tr><td align="center" valign="top">-</td><td>For each valid i, 0 &lt;= <b>p</b>[i] &lt;= i.</td></tr><tr><td align="center" valign="top">-</td><td>Each element in <b>L</b> and <b>R</b> will be between 1 and 1,000, inclusive.</td></tr><tr><td align="center" valign="top">-</td><td><b>a</b> will contain between 1 and 50 elements, inclusive.</td></tr><tr><td align="center" valign="top">-</td><td><b>a</b> and <b>b</b> will contain the same number of elements.</td></tr><tr><td align="center" valign="top">-</td><td>Each element in <b>a</b> and <b>b</b> will be between 0 and n-1, inclusive.</td></tr><tr><td colspan="2"><h3>Examples</h3></td></tr><tr><td align="center" nowrap="true">0)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>{0,1,2,3}</pre></td></tr><tr><td><pre>{1,2,3,4}</pre></td></tr><tr><td><pre>{10,20,30,40}</pre></td></tr><tr><td><pre>{0}</pre></td></tr><tr><td><pre>{4}</pre></td></tr></table></td></tr><tr><td><pre>Returns: 64</pre></td></tr><tr><td><table><tr><td colspan="2"><pre>
There are 2 valid solutions:
0-(-1-(-2-)-3-)-4
0-(-1-)-2-(-3-)-4
In the first one, the cost is 1 + 2 + 30 + 40 = 73.
In the second one, the cost is 1 + 20 + 3 + 40 = 64.
So we should return 64.
</pre></td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">1)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>{0,1,2,3}</pre></td></tr><tr><td><pre>{1,2,3,4}</pre></td></tr><tr><td><pre>{10,20,30,40}</pre></td></tr><tr><td><pre>{0}</pre></td></tr><tr><td><pre>{3}</pre></td></tr></table></td></tr><tr><td><pre>Returns: -1</pre></td></tr><tr><td><table><tr><td colspan="2">When we read from 0 to 3 we will get a string with 3 characters and that can't be a valid parentheses sequence. So there is no solution.</td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">2)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>{0,1,2,3}</pre></td></tr><tr><td><pre>{1,2,3,4}</pre></td></tr><tr><td><pre>{10,20,30,40}</pre></td></tr><tr><td><pre>{2}</pre></td></tr><tr><td><pre>{2}</pre></td></tr></table></td></tr><tr><td><pre>Returns: 10</pre></td></tr><tr><td><table><tr><td colspan="2"></td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">3)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>{0,1,1,3,4,4}</pre></td></tr><tr><td><pre>{1,2,3,4,5,6}</pre></td></tr><tr><td><pre>{100,200,300,400,500,600}</pre></td></tr><tr><td><pre>{0,0,2,2,1}</pre></td></tr><tr><td><pre>{5,6,5,6,4}</pre></td></tr></table></td></tr><tr><td><pre>Returns: 1704</pre></td></tr><tr><td><table><tr><td colspan="2"></td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">4)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>{0,1,1,3,4,4}</pre></td></tr><tr><td><pre>{1,2,3,4,5,6}</pre></td></tr><tr><td><pre>{100,200,300,400,500,600}</pre></td></tr><tr><td><pre>{0,0,2,2}</pre></td></tr><tr><td><pre>{5,6,5,6}</pre></td></tr></table></td></tr><tr><td><pre>Returns: 1605</pre></td></tr><tr><td><table><tr><td colspan="2"></td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">5)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>{0, 0, 2, 0, 2, 3, 1, 5, 8, 2, 1, 6, 5, 5, 10, 11, 8, 12, 1}</pre></td></tr><tr><td><pre>{959, 475, 349, 884, 853, 73, 883, 737, 910, 435, 207, 1, 484, 490, 485, 968, 19, 428, 648}</pre></td></tr><tr><td><pre>{899, 770, 514, 327, 626, 84, 244, 695, 669, 138, 480, 778, 368, 892, 440, 976, 957, 959, 107}</pre></td></tr><tr><td><pre>{7, 13, 13, 5, 6, 1, 7}</pre></td></tr><tr><td><pre>{10, 13, 6, 17, 4, 2, 12}</pre></td></tr></table></td></tr><tr><td><pre>Returns: 9813</pre></td></tr><tr><td><table><tr><td colspan="2"></td></tr></table></td></tr></table></td></tr></table><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc.  Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited.  (c)2003, TopCoder, Inc.  All rights reserved.  </p></body></html>
